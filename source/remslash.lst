
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -Wall -q -c -o remslash.prg -L remslash.lst main.asm
; Mon Oct 14 17:38:19 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm

=$801					SourceCode = $801
=$b000					UserDictionary = $B000
=$b800					UserCode = $B800

;******  Processing file: data.asm

>0008					codePtr:	.word ?							; code pointer (in BASIC code)
>000a					dictPtr:	.word ?							; next free space in user dictionary
>000c					objectPtr:	.word ?							; next free space for object code
>000e					cStackPtr:	.word ? 						; compiler stack pointer
>0010					zTemp0:		.word ?							; temporary words
>0012					zTemp1:		.word ?
>0014					zTemp2: 	.word ?
=16					tokenBufferSize = 16 						; max size of a token.
>0016					tokenBuffer:.fill tokenBufferSize+1 		; current token buffer as ASCIIZ
>0027					lineNumber:	.word ?							; current line number
>0029					currentType:.byte ?							; current type. $00 if should get one.
>002a					currentYX:	.word ?							; current XY value to return.
=$0780					zeroPageStore = $0780 						; store for $00-$7F
=$0700					comStack = $0700							; stack used when compiling
=$80					cStackSize = $80 							; size of compiler stack (max 128)
=$06fd					stackTemp = $06FD 							; stack temporary store.
=$8f					TOKEN_REM = $8F 							; REM Token.
=$ff					SMK_TOPSTACK = $FF 							; this marks the top of the compiler stack
=$c0					ELT_PROCEDURE = $C0 						; retrieved element types
=$00					ELT_VARIABLE = $00
=$01					ELT_UNKNOWNID = $01
=$02					ELT_CONSTANT = $02
=$03					ELT_STRING = $03

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm


;******  Processing file: generated/tokens.inc

=$80					KWD_WORD                     = $80; WORD
=$81					KWD_WHILE                    = $81; WHILE
=$82					KWD_WEND                     = $82; WEND
=$83					KWD_UNTIL                    = $83; UNTIL
=$84					KWD_TIMES                    = $84; TIMES
=$85					KWD_TEND                     = $85; TEND
=$86					KWD_REPEAT                   = $86; REPEAT
=$87					KWD_INLINE                   = $87; INLINE
=$88					KWD_IF                       = $88; IF
=$89					KWD_ENDIF                    = $89; ENDIF
=$8a					KWD_ELSE                     = $8a; ELSE
=$8b					KWD_BYTE                     = $8b; BYTE
=$8c					KWD_GREATERGREATER           = $8c; >>
=$8d					KWD_GREATEREQUAL             = $8d; >=
=$8e					KWD_GREATER                  = $8e; >
=$8f					KWD_EQUAL                    = $8f; =
=$90					KWD_LESSGREATER              = $90; <>
=$91					KWD_LESSLESS                 = $91; <<
=$92					KWD_COLON                    = $92; :
=$93					KWD_SLASH                    = $93; /
=$94					KWD_MINUSMINUS               = $94; --
=$95					KWD_MINUS                    = $95; -
=$96					KWD_PLUSPLUS                 = $96; ++
=$97					KWD_PLUS                     = $97; +
=$98					KWD_STAR                     = $98; *
=$99					KWD_AMP                      = $99; &

;******  Return to file: main.asm

.a000	4c 03 a0	jmp $a003			jmp 	CompileRun
.a003					CompileRun:
.a003	20 8f a3	jsr $a38f			jsr 	LoadBasicCode
.a006	20 88 a1	jsr $a188			jsr 	Compiler
.a009	60		rts				rts
.a00a					ErrorHandler:
>a00a	ff						.byte 	$FF

;******  Processing file: analysis/element.asm

.a00b					GetElement:
.a00b	a6 2a		ldx $2a				ldx 	currentYX 					; get the current values.
.a00d	a4 2b		ldy $2b				ldy 	currentYX+1
.a00f	a5 29		lda $29				lda 	currentType
.a011	38		sec				sec
.a012	d0 08		bne $a01c			bne 	_GEExit 					; if current then exit
.a014	20 20 a0	jsr $a020			jsr 	GetNextElement 				; get the next element
.a017	a5 29		lda $29				lda 	currentType 				; if one was got.
.a019	d0 f0		bne $a00b			bne 	GetElement 					; try again, it will pass now
.a01b	18		clc				clc
.a01c					_GEExit:
.a01c	60		rts				rts
.a01d					NextElement:
.a01d	64 29		stz $29				stz 	currentType 				; clearing this will advance to the next one.
.a01f	60		rts				rts
.a020					GetNextElement:
.a020	64 29		stz $29				stz 	currentType 				; clear the current type in case there's nothing.
.a022	20 1c a1	jsr $a11c			jsr 	FindNextToken
.a025	b0 01		bcs $a028			bcs 	_GNEData 					; if CS there's something to get.
.a027	60		rts				rts
.a028					_GNEData:
.a028	b2 08		lda ($08)			lda 	(codePtr)
.a02a	c9 22		cmp #$22			cmp 	#'"'
.a02c	d0 2f		bne $a05d			bne 	_GNENotQString
.a02e	18		clc				clc 								; set currentYX to the following character
.a02f	a5 08		lda $08				lda 	codePtr 					; (e.g. the start of the string.)
.a031	69 01		adc #$01			adc 	#1
.a033	85 2a		sta $2a				sta 	currentYX
.a035	a5 09		lda $09				lda 	codePtr+1
.a037	69 00		adc #$00			adc 	#0
.a039	85 2b		sta $2b				sta 	currentYX+1
.a03b	a0 00		ldy #$00			ldy 	#0 							; skip forward to next quote
.a03d					_GNEQSkip:
.a03d	c8		iny				iny
.a03e	b1 08		lda ($08),y			lda 	(codePtr),y
.a040	f0 0a		beq $a04c			beq 	_GNENoQuote 				; missing closing quote
.a042	c9 22		cmp #$22			cmp 	#'"'
.a044	d0 f7		bne $a03d			bne 	_GNEQSkip
.a046	c8		iny				iny 								; Y is the amount to skip
.a047	a9 03		lda #$03			lda 	#ELT_STRING
.a049	4c c5 a0	jmp $a0c5			jmp 	_GNEExit
.a04c					_GNENoQuote:
.a04c	20 0a a0	jsr $a00a			jsr 	ErrorHandler
>a04f	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>a057	51 55 4f 54 45 00
.a05d					_GNENotQString:
.a05d	c9 24		cmp #$24			cmp 	#"$"						; is there a dollar, the hex constant marker.
.a05f	d0 23		bne $a084			bne 	_GNENotHexadecimal
.a061	20 81 a1	jsr $a181			jsr 	IncCodePtr 					; point to next token.
.a064	20 d2 a0	jsr $a0d2			jsr 	ExtractAlphaNumericToken 	; pull an alphanumeric token -> buffer.
.a067	48		pha				pha 								; save length
.a068	a9 10		lda #$10			lda 	#16 						; use base 16.
.a06a	20 0f a3	jsr $a30f			jsr 	ConstantToInteger 			; convert to integer
.a06d	90 0a		bcc $a079			bcc 	_GNEBadHex 					; failed
.a06f	86 2a		stx $2a				stx 	currentYX
.a071	84 2b		sty $2b				sty 	currentYX+1
.a073	7a		ply				ply 								; length in Y
.a074	a9 02		lda #$02			lda 	#ELT_CONSTANT 				; it's a constant
.a076	4c c5 a0	jmp $a0c5			jmp 	_GNEExit
.a079					_GNEBadHex:
.a079	20 0a a0	jsr $a00a			jsr 	ErrorHandler
>a07c	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.a084					_GNENotHexadecimal:
.a084	20 c9 a1	jsr $a1c9			jsr 	DictionarySearch
.a087	90 3c		bcc $a0c5			bcc 	_GNENotKnown
.a089	86 10		stx $10				stx 	zTemp0 						; save entry address.
.a08b	84 11		sty $11				sty 	zTemp0+1
.a08d	a0 04		ldy #$04			ldy 	#4 							; find how long it is, +5
.a08f					_GNEGetLength:
.a08f	c8		iny				iny
.a090	b1 10		lda ($10),y			lda 	(zTemp0),y
.a092	10 fb		bpl $a08f			bpl 	_GNEGetLength
.a094	98		tya				tya 								; actual token length
.a095	38		sec				sec
.a096	e9 04		sbc #$04			sbc 	#5-1
.a098	48		pha				pha 								; save length on the stack.
.a099	a0 02		ldy #$02			ldy 	#2							; copy the data to the XY
.a09b	b1 10		lda ($10),y			lda 	(zTemp0),y
.a09d	85 2a		sta $2a				sta 	currentYX
.a09f	c8		iny				iny
.a0a0	b1 10		lda ($10),y			lda 	(zTemp0),y
.a0a2	85 2b		sta $2b				sta 	currentYX+1
.a0a4	a0 01		ldy #$01			ldy 	#1 							; get type
.a0a6	b1 10		lda ($10),y			lda 	(zTemp0),y
.a0a8	29 c0		and #$c0			and 	#$C0 						; is it a procedure 11xxx xxxx
.a0aa	c9 c0		cmp #$c0			cmp 	#$C0
.a0ac	f0 14		beq $a0c2			beq 	_GNETokenType 				; if so, exit with type $C0
.a0ae	b1 10		lda ($10),y			lda 	(zTemp0),y 					; get type and clear bit 7
.a0b0	29 7f		and #$7f			and 	#$7F
.a0b2	f0 0e		beq $a0c2			beq 	_GNETokenType 				; was $00 or $80, local/global.
.a0b4	3a		dec a				dec 	a
.a0b5	f0 09		beq $a0c0			beq 	_GNEIsToken 				; if $01, then it is a token.
.a0b7	20 0a a0	jsr $a00a			jsr 	ErrorHandler
>a0ba	3f 49 4e 54 4c 00				.text 	"?INTL",$00
.a0c0					_GNEIsToken:
.a0c0	a5 2a		lda $2a				lda 	currentYX 					; return the token itself.
.a0c2					_GNETokenType:
.a0c2	7a		ply				ply 								; length into Y
.a0c3	80 00		bra $a0c5			bra 	_GNEExit
.a0c5					_GNENotKnown:
.a0c5					_GNEExit:
.a0c5	85 29		sta $29				sta 	currentType 				; save current type
.a0c7	98		tya				tya 								; add skip to code pointer
.a0c8	18		clc				clc
.a0c9	65 08		adc $08				adc 	codePtr
.a0cb	85 08		sta $08				sta 	codePtr
.a0cd	90 02		bcc $a0d1			bcc 	_GNENoCarry
.a0cf	e6 09		inc $09				inc 	codePtr+1
.a0d1					_GNENoCarry:
.a0d1	60		rts				rts
.a0d2					ExtractAlphaNumericToken:
.a0d2	da		phx				phx
.a0d3	5a		phy				phy
.a0d4	a0 ff		ldy #$ff			ldy 	#255 						; start position-1
.a0d6					_EANTLoop:
.a0d6	c8		iny				iny 								; bump index
.a0d7	c0 10		cpy #$10			cpy 	#tokenBufferSize 			; check if too big.
.a0d9	f0 1f		beq $a0fa			beq 	_EANTLength
.a0db	b1 08		lda ($08),y			lda 	(codePtr),y 				; copy character
.a0dd	99 16 00	sta $0016,y			sta 	tokenBuffer,y
.a0e0	20 03 a1	jsr $a103			jsr 	IsCharIdentifier 			; if identifier go round again
.a0e3	b0 f1		bcs $a0d6			bcs 	_EANTLoop
.a0e5	c0 00		cpy #$00			cpy 	#0 							; no token ???
.a0e7	f0 11		beq $a0fa			beq 	_EANTLength
.a0e9	b9 15 00	lda $0015,y			lda 	tokenBuffer-1,y 			; set bit 7 of last character
.a0ec	09 80		ora #$80			ora 	#$80
.a0ee	99 15 00	sta $0015,y			sta 	tokenBuffer-1,y
.a0f1	a9 00		lda #$00			lda 	#0 							; make it ASCIIZ
.a0f3	99 16 00	sta $0016,y			sta 	tokenBuffer,y
.a0f6	98		tya				tya 								; return length in A.
.a0f7	7a		ply				ply
.a0f8	fa		plx				plx
.a0f9	60		rts				rts
.a0fa					_EANTLength:
.a0fa	20 0a a0	jsr $a00a			jsr 	ErrorHandler
>a0fd	54 4f 4b 45 4e 00				.text 	"TOKEN",$00
.a103					IsCharIdentifier:
.a103	c9 2e		cmp #$2e			cmp 	#"."						; dot always is.
.a105	f0 12		beq $a119			beq 	_ICIYes
.a107	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.a109	90 0c		bcc $a117			bcc 	_ICINo
.a10b	c9 3a		cmp #$3a			cmp 	#"9"+1
.a10d	90 0a		bcc $a119			bcc 	_ICIYes
.a10f	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.a111	90 04		bcc $a117			bcc 	_ICINo
.a113	c9 5b		cmp #$5b			cmp 	#"Z"+1
.a115	90 02		bcc $a119			bcc 	_ICIYes
.a117	18		clc		_ICINo:	clc
.a118	60		rts				rts
.a119	38		sec		_ICIYes:sec
.a11a	60		rts				rts
.a11b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: analysis/findtoken.asm

.a11c					FindNextToken:
.a11c	48		pha				pha
.a11d	da		phx				phx
.a11e	5a		phy				phy
.a11f	b2 08		lda ($08)			lda 	(codePtr) 					; check not at end of line.
.a121	d0 4c		bne $a16f			bne  	_FNTNotEOL					; not end of line.
.a123					_FNTEndOfLine:
.a123	20 81 a1	jsr $a181			jsr 	IncCodePtr					; advance to offset word.
.a126					_FNTNextLine:
.a126	b2 08		lda ($08)			lda 	(codePtr) 					; if the offset word is zero.
.a128	a0 01		ldy #$01			ldy 	#1 							; then exit
.a12a	12 08		ora ($08)			ora 	(codePtr)
.a12c	d0 04		bne $a132			bne 	_FNTNotEndProgram
.a12e	18		clc				clc 								; exit with carry clear == fail.
.a12f	4c 7d a1	jmp $a17d			jmp 	_FNTExit
.a132					_FNTNotEndProgram:
.a132	a0 05		ldy #$05			ldy 	#5 							; the 5th character (2nd in line) must
.a134	b1 08		lda ($08),y			lda 	(codePtr),y 				; be a slash.
.a136	c9 2f		cmp #$2f			cmp 	#"/"
.a138	d0 11		bne $a14b			bne 	_FNTGoNextLine
.a13a	88		dey				dey		 							; check for REM at the start of the line.
.a13b	b1 08		lda ($08),y			lda 	(codePtr),y
.a13d	c9 8f		cmp #$8f			cmp 	#TOKEN_REM
.a13f	f0 17		beq $a158			beq 	_FNTFoundCode 				; if so then we have found REM/
.a141	c9 2f		cmp #$2f			cmp 	#"/" 						; if first character is /, then this is //
.a143	d0 06		bne $a14b			bne 	_FNTGoNextLine
.a145	a9 8f		lda #$8f			lda 	#TOKEN_REM 					; convert it to REM/
.a147	91 08		sta ($08),y			sta 	(codePtr),y
.a149	80 0d		bra $a158			bra 	_FNTFoundCode 				; and carry on as found code.
.a14b					_FNTGoNextLine:
.a14b	a0 01		ldy #$01			ldy 	#1 							; read MSB to link through
.a14d	b1 08		lda ($08),y			lda 	(codePtr),y
.a14f	aa		tax				tax
.a150	b2 08		lda ($08)			lda 	(codePtr) 					; read LSB
.a152	85 08		sta $08				sta 	codePtr 					; follow link.
.a154	86 09		stx $09				stx 	codePtr+1
.a156	80 ce		bra $a126			bra 	_FNTNextLine 				; go through to next line.
.a158					_FNTFoundCode:
.a158	a0 02		ldy #$02			ldy 	#2 							; copy current line number so the error
.a15a	b1 08		lda ($08),y			lda 	(codePtr),y 				; handler knows the line to report.
.a15c	85 27		sta $27				sta 	lineNumber
.a15e	c8		iny				iny
.a15f	b1 08		lda ($08),y			lda 	(codePtr),y
.a161	85 28		sta $28				sta 	lineNumber+1
.a163	c8		iny				iny
.a164	18		clc				clc
.a165	a5 08		lda $08				lda 	codePtr 					; add 6 to the codePtr.
.a167	69 06		adc #$06			adc 	#6							; (<offset>,<line#>,REM token, slash)
.a169	85 08		sta $08				sta 	codePtr
.a16b	90 02		bcc $a16f			bcc 	_FNTNotEOL
.a16d	e6 09		inc $09				inc 	codePtr+1
.a16f					_FNTNotEOL:
.a16f	b2 08		lda ($08)			lda 	(codePtr) 					; read byte at codePtr
.a171	f0 b0		beq $a123			beq 	_FNTEndOfLine 				; if zero goto the next line.
.a173	c9 20		cmp #$20			cmp 	#" "						; is it space ?
.a175	d0 05		bne $a17c			bne 	_FNTNotSpace 				; found a non space character, start extracting.
.a177	20 81 a1	jsr $a181			jsr 	IncCodePtr 					; space - go past it and loop round
.a17a	80 f3		bra $a16f			bra 	_FNTNotEOL
.a17c					_FNTNotSpace:
.a17c	38		sec				sec 								; set carry to signify token found.
.a17d					_FNTExit:
.a17d	7a		ply				ply
.a17e	fa		plx				plx
.a17f	68		pla				pla
.a180	60		rts				rts
.a181					IncCodePtr:
.a181	e6 08		inc $08				inc 	codePtr
.a183	d0 02		bne $a187			bne 	_NoCarry
.a185	e6 09		inc $09				inc 	codePtr+1
.a187					_NoCarry:
.a187	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/compiler.asm

.a188					Compiler:
.a188	ba		tsx				tsx 										; save stack pointer
.a189	8e fd 06	stx $06fd			stx 	stackTemp
.a18c	20 77 a3	jsr $a377			jsr 	StateSave 							; save zero page and stack
.a18f	a9 00		lda #$00			lda 	#(SourceCode-1) & $FF
.a191	85 08		sta $08				sta 	codePtr
.a193	a9 08		lda #$08			lda 	#(SourceCode-1) >> 8
.a195	85 09		sta $09				sta 	codePtr+1
.a197	a9 00		lda #$00			lda 	#(UserDictionary) & $FF
.a199	85 0a		sta $0a				sta 	dictPtr
.a19b	a9 b0		lda #$b0			lda 	#(UserDictionary) >> 8
.a19d	85 0b		sta $0b				sta 	dictPtr+1
.a19f	9c 00 b0	stz $b000			stz 	UserDictionary 						; clear the user dictionary.
.a1a2	a9 00		lda #$00			lda 	#(UserCode) & $FF
.a1a4	85 0c		sta $0c				sta 	objectPtr
.a1a6	a9 b8		lda #$b8			lda 	#(UserCode) >> 8
.a1a8	85 0d		sta $0d				sta 	objectPtr+1
.a1aa	a9 7f		lda #$7f			lda 	#(comStack+cStackSize-1) & $FF
.a1ac	85 0e		sta $0e				sta 	cStackPtr
.a1ae	a9 07		lda #$07			lda 	#(comStack+cStackSize-1) >> 8
.a1b0	85 0f		sta $0f				sta 	cStackPtr+1
.a1b2	a9 ff		lda #$ff			lda 	#SMK_TOPSTACK 						; put a dummy value to pop.
.a1b4	92 0e		sta ($0e)			sta 	(cStackPtr)
.a1b6	64 29		stz $29				stz 	currentType 						; current type cleared to get first.
.a1b8					l1:
.a1b8	20 0b a0	jsr $a00b			jsr 	GetElement
>a1bb	ff						.byte 	$FF
.a1bc	20 1d a0	jsr $a01d			jsr 	NextElement
.a1bf	80 f7		bra $a1b8			bra 	l1
.a1c1					CompileTerminate:
.a1c1	ae fd 06	ldx $06fd			ldx 	stackTemp 							; restore the stack pointer
.a1c4	9a		txs				txs
.a1c5	20 84 a3	jsr $a384			jsr 	StateRestore 						; restore ZPage and Exit.
.a1c8	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/dictionary.asm

.a1c9					DictionarySearch:
.a1c9	a2 00		ldx #$00			ldx		#UserDictionary & $FF 		; search user dictionary
.a1cb	a0 b0		ldy #$b0			ldy 	#UserDictionary >> 8
.a1cd	20 da a1	jsr $a1da			jsr 	DictionarySearchSingle
.a1d0	b0 07		bcs $a1d9			bcs 	_DSExit 					; successful ?
.a1d2	a2 42		ldx #$42			ldx 	#StandardDictionary & $FF 	; search compiler dictionary
.a1d4	a0 a2		ldy #$a2			ldy 	#StandardDictionary >> 8
.a1d6	20 da a1	jsr $a1da			jsr 	DictionarySearchSingle
.a1d9					_DSExit:
.a1d9	60		rts				rts
.a1da					DictionarySearchSingle:
.a1da	86 10		stx $10				stx 	zTemp0 						; save search dictionary address
.a1dc	84 11		sty $11				sty 	zTemp0+1
.a1de	38		sec				sec 								; zTemp1 = codePtr - 5 ; this is because
.a1df	a5 08		lda $08				lda 	codePtr 					; the text data starts 5 bytes into the record.
.a1e1	e9 05		sbc #$05			sbc 	#5
.a1e3	85 12		sta $12				sta 	zTemp1
.a1e5	a5 09		lda $09				lda 	codePtr+1
.a1e7	e9 00		sbc #$00			sbc 	#0
.a1e9	85 13		sta $13				sta 	zTemp1+1
.a1eb					_DSSLoop:
.a1eb	b2 10		lda ($10)			lda 	(zTemp0)					; reached the end ?
.a1ed	d0 02		bne $a1f1			bne 	_DSSEntry
.a1ef	18		clc				clc 								; return with carry clear
.a1f0	60		rts				rts
.a1f1					_DSSEntry:
.a1f1	a0 05		ldy #$05			ldy 	#5 							; compare the names. Dictionary offset starts at five.
.a1f3					_DSSCompare:
.a1f3	b1 10		lda ($10),y			lda 	(zTemp0),y 					; get corresponding character out (back 5)
.a1f5	51 12		eor ($12),y			eor 	(zTemp1),y 					; does it match ? - $00 or $80 if so.
.a1f7	0a		asl a				asl 	a 							; put bit 7 into C.
.a1f8	d0 0d		bne $a207			bne 	_DSSGoNext 					; if not, go to the next entry.
.a1fa	c8		iny				iny 								; point to next character.
.a1fb	90 f6		bcc $a1f3			bcc 	_DSSCompare
.a1fd	a0 01		ldy #$01			ldy 	#1 							; type into A.
.a1ff	b1 10		lda ($10),y			lda 	(zTemp0),y
.a201	a6 10		ldx $10				ldx 	zTemp0 						; successful, so return address in XY and carry set.
.a203	a4 11		ldy $11				ldy 	zTemp0+1
.a205	38		sec				sec
.a206	60		rts				rts
.a207					_DSSGoNext:
.a207	18		clc				clc
.a208	b2 10		lda ($10)			lda 	(zTemp0)					; offset, add it to current address.
.a20a	65 10		adc $10				adc 	zTemp0
.a20c	85 10		sta $10				sta 	zTemp0
.a20e	90 db		bcc $a1eb			bcc 	_DSSLoop
.a210	e6 11		inc $11				inc 	zTemp0+1
.a212	80 d7		bra $a1eb			bra 	_DSSLoop
.a214					DictionaryCreate:
.a214	48		pha				pha
.a215	da		phx				phx
.a216	5a		phy				phy
.a217	5a		phy				phy 								; save data.high
.a218	a0 01		ldy #$01			ldy 	#1							; write the type byte out.
.a21a	91 0a		sta ($0a),y			sta 	(dictPtr),y
.a21c	8a		txa				txa 								; write data low
.a21d	c8		iny				iny
.a21e	91 0a		sta ($0a),y			sta 	(dictPtr),y
.a220	68		pla				pla 								; write data high
.a221	c8		iny				iny
.a222	91 0a		sta ($0a),y			sta 	(dictPtr),y
.a224	c8		iny				iny 								; Y is now 5 - copy token name.
.a225					_DCCopyName:
.a225	b9 11 00	lda $0011,y			lda 	tokenBuffer-5,y
.a228	91 0a		sta ($0a),y			sta 	(dictPtr),y
.a22a	c8		iny				iny
.a22b	0a		asl a				asl 	a
.a22c	90 f7		bcc $a225			bcc 	_DCCopyName
.a22e	a9 00		lda #$00			lda 	#0 							; write the zero marking dictionary end
.a230	91 0a		sta ($0a),y			sta 	(dictPtr),y
.a232	98		tya				tya 								; this is the offsest
.a233	92 0a		sta ($0a)			sta 	(dictPtr) 					; put as the first byte.
.a235	18		clc				clc 								; add offset to dictptr
.a236	65 0a		adc $0a				adc 	dictPtr 					; updating the next free slot.
.a238	85 0a		sta $0a				sta 	dictPtr
.a23a	90 02		bcc $a23e			bcc 	_DCNoCarry
.a23c	e6 0a		inc $0a				inc 	dictPtr
.a23e					_DCNoCarry:
.a23e	7a		ply				ply
.a23f	fa		plx				plx
.a240	68		pla				pla
.a241	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/dictionary.inc

.a242					StandardDictionary:
>a242	09					.byte 9 ; *** WORD ***
>a243	01					.byte $01
>a244	80 00 00				.byte $80,$00,$00
>a247	57 4f 52 c4				.byte $57,$4f,$52,$c4
>a24b	0a					.byte 10 ; *** WHILE ***
>a24c	01					.byte $01
>a24d	81 00 00				.byte $81,$00,$00
>a250	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5
>a255	09					.byte 9 ; *** WEND ***
>a256	01					.byte $01
>a257	82 00 00				.byte $82,$00,$00
>a25a	57 45 4e c4				.byte $57,$45,$4e,$c4
>a25e	0a					.byte 10 ; *** UNTIL ***
>a25f	01					.byte $01
>a260	83 00 00				.byte $83,$00,$00
>a263	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc
>a268	0a					.byte 10 ; *** TIMES ***
>a269	01					.byte $01
>a26a	84 00 00				.byte $84,$00,$00
>a26d	54 49 4d 45 d3				.byte $54,$49,$4d,$45,$d3
>a272	09					.byte 9 ; *** TEND ***
>a273	01					.byte $01
>a274	85 00 00				.byte $85,$00,$00
>a277	54 45 4e c4				.byte $54,$45,$4e,$c4
>a27b	0b					.byte 11 ; *** REPEAT ***
>a27c	01					.byte $01
>a27d	86 00 00				.byte $86,$00,$00
>a280	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4
>a286	0b					.byte 11 ; *** INLINE ***
>a287	01					.byte $01
>a288	87 00 00				.byte $87,$00,$00
>a28b	49 4e 4c 49 4e c5			.byte $49,$4e,$4c,$49,$4e,$c5
>a291	07					.byte 7 ; *** IF ***
>a292	01					.byte $01
>a293	88 00 00				.byte $88,$00,$00
>a296	49 c6					.byte $49,$c6
>a298	0a					.byte 10 ; *** ENDIF ***
>a299	01					.byte $01
>a29a	89 00 00				.byte $89,$00,$00
>a29d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6
>a2a2	09					.byte 9 ; *** ELSE ***
>a2a3	01					.byte $01
>a2a4	8a 00 00				.byte $8a,$00,$00
>a2a7	45 4c 53 c5				.byte $45,$4c,$53,$c5
>a2ab	09					.byte 9 ; *** BYTE ***
>a2ac	01					.byte $01
>a2ad	8b 00 00				.byte $8b,$00,$00
>a2b0	42 59 54 c5				.byte $42,$59,$54,$c5
>a2b4	07					.byte 7 ; *** >> ***
>a2b5	01					.byte $01
>a2b6	8c 00 00				.byte $8c,$00,$00
>a2b9	3e be					.byte $3e,$be
>a2bb	07					.byte 7 ; *** >= ***
>a2bc	01					.byte $01
>a2bd	8d 00 00				.byte $8d,$00,$00
>a2c0	3e bd					.byte $3e,$bd
>a2c2	06					.byte 6 ; *** > ***
>a2c3	01					.byte $01
>a2c4	8e 00 00				.byte $8e,$00,$00
>a2c7	be					.byte $be
>a2c8	06					.byte 6 ; *** = ***
>a2c9	01					.byte $01
>a2ca	8f 00 00				.byte $8f,$00,$00
>a2cd	bd					.byte $bd
>a2ce	07					.byte 7 ; *** <> ***
>a2cf	01					.byte $01
>a2d0	90 00 00				.byte $90,$00,$00
>a2d3	3c be					.byte $3c,$be
>a2d5	07					.byte 7 ; *** << ***
>a2d6	01					.byte $01
>a2d7	91 00 00				.byte $91,$00,$00
>a2da	3c bc					.byte $3c,$bc
>a2dc	06					.byte 6 ; *** : ***
>a2dd	01					.byte $01
>a2de	92 00 00				.byte $92,$00,$00
>a2e1	ba					.byte $ba
>a2e2	06					.byte 6 ; *** / ***
>a2e3	01					.byte $01
>a2e4	93 00 00				.byte $93,$00,$00
>a2e7	af					.byte $af
>a2e8	07					.byte 7 ; *** -- ***
>a2e9	01					.byte $01
>a2ea	94 00 00				.byte $94,$00,$00
>a2ed	2d ad					.byte $2d,$ad
>a2ef	06					.byte 6 ; *** - ***
>a2f0	01					.byte $01
>a2f1	95 00 00				.byte $95,$00,$00
>a2f4	ad					.byte $ad
>a2f5	07					.byte 7 ; *** ++ ***
>a2f6	01					.byte $01
>a2f7	96 00 00				.byte $96,$00,$00
>a2fa	2b ab					.byte $2b,$ab
>a2fc	06					.byte 6 ; *** + ***
>a2fd	01					.byte $01
>a2fe	97 00 00				.byte $97,$00,$00
>a301	ab					.byte $ab
>a302	06					.byte 6 ; *** * ***
>a303	01					.byte $01
>a304	98 00 00				.byte $98,$00,$00
>a307	aa					.byte $aa
>a308	06					.byte 6 ; *** & ***
>a309	01					.byte $01
>a30a	99 00 00				.byte $99,$00,$00
>a30d	a6					.byte $a6
>a30e	00					.byte $00

;******  Return to file: main.asm


;******  Processing file: utility/constant.asm

.a30f					ConstantToInteger:
.a30f	a2 00		ldx #$00			ldx 	#0 							; character offset.
.a311	85 12		sta $12				sta 	zTemp1 						; save base in zTemp1
.a313	b5 16		lda $16,x			lda 	tokenBuffer,x 				; get first character
.a315	f0 5e		beq $a375			beq 	_CTIFail 					; if zero, then it has failed anyway.
.a317	64 10		stz $10				stz 	zTemp0 						; clear the result.
.a319	64 11		stz $11				stz 	zTemp0+1
.a31b					_CTILoop:
.a31b	a5 10		lda $10				lda 	zTemp0 						; copy current to zTemp2
.a31d	85 14		sta $14				sta 	zTemp2
.a31f	a5 11		lda $11				lda 	zTemp0+1
.a321	85 15		sta $15				sta 	zTemp2+1
.a323	64 10		stz $10				stz 	zTemp0 						; clear result
.a325	64 11		stz $11				stz 	zTemp0+1
.a327	a4 12		ldy $12				ldy 	zTemp1 						; Y contains the base.
.a329					_CTIMultiply:
.a329	98		tya				tya 								; shift Y right into carry.
.a32a	4a		lsr a				lsr 	a
.a32b	a8		tay				tay
.a32c	90 0d		bcc $a33b			bcc 	_CTINoAdd 					; skip if CC, e.g. LSB was zero
.a32e	18		clc				clc
.a32f	a5 14		lda $14				lda 	zTemp2 						; add zTemp2 into zTemp0
.a331	65 10		adc $10				adc 	zTemp0
.a333	85 10		sta $10				sta 	zTemp0
.a335	a5 15		lda $15				lda 	zTemp2+1
.a337	65 11		adc $11				adc 	zTemp0+1
.a339	85 11		sta $11				sta 	zTemp0+1
.a33b					_CTINoAdd:
.a33b	06 14		asl $14				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a33d	26 15		rol $15				rol 	zTemp2+1
.a33f	c0 00		cpy #$00			cpy 	#0 							; multiply finished ?
.a341	d0 e6		bne $a329			bne 	_CTIMultiply
.a343	b5 16		lda $16,x			lda 	tokenBuffer,x 				; check in range 0-9 A-F
.a345	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a347	c9 30		cmp #$30			cmp 	#"0"
.a349	90 2a		bcc $a375			bcc 	_CTIFail
.a34b	c9 3a		cmp #$3a			cmp 	#"9"+1
.a34d	90 0b		bcc $a35a			bcc 	_CTIOkay
.a34f	c9 41		cmp #$41			cmp 	#"A"
.a351	90 22		bcc $a375			bcc 	_CTIFail
.a353	c9 46		cmp #$46			cmp 	#"F"
.a355	b0 1e		bcs $a375			bcs 	_CTIFail
.a357	38		sec				sec 								; hex adjust
.a358	e9 07		sbc #$07			sbc 	#7
.a35a					_CTIOkay:
.a35a	38		sec				sec
.a35b	e9 30		sbc #$30			sbc 	#48
.a35d	c5 12		cmp $12				cmp 	zTemp1  					; if >= base then fail.
.a35f	b0 14		bcs $a375			bcs 	_CTIFail
.a361	d8		cld				cld
.a362	65 10		adc $10				adc 	zTemp0 						; add into the current value
.a364	85 10		sta $10				sta 	zTemp0
.a366	90 02		bcc $a36a			bcc 	_CTINoCarry
.a368	e6 11		inc $11				inc 	zTemp0+1
.a36a					_CTINoCarry:
.a36a	e8		inx				inx 								; get next in buffer
.a36b	b5 16		lda $16,x			lda 	tokenBuffer,x
.a36d	d0 ac		bne $a31b			bne 	_CTILoop
.a36f	a6 10		ldx $10				ldx 	zTemp0 						; return result
.a371	a4 11		ldy $11				ldy 	zTemp0+1
.a373	38		sec				sec
.a374	60		rts				rts
.a375					_CTIFail:
.a375	18		clc				clc
.a376	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/state.asm

.a377					StateSave:
.a377	a2 7f		ldx #$7f			ldx 	#$7F 						; copy zero page, blanking $00-$7F
.a379	b5 00		lda $00,x	_SSCopy:lda 	$00,x
.a37b	9d 80 07	sta $0780,x			sta 	zeroPageStore,x
.a37e	74 00		stz $00,x			stz 	$00,x
.a380	ca		dex				dex
.a381	10 f6		bpl $a379			bpl 	_SSCopy
.a383	60		rts				rts
.a384					StateRestore:
.a384	a2 7f		ldx #$7f			ldx 	#$7F 						; copy zero page, blanking $00-$7F
.a386	bd 80 07	lda $0780,x	_SRCopy:lda 	zeroPageStore,x
.a389	95 00		sta $00,x			sta 	$00,x
.a38b	ca		dex				dex
.a38c	10 f8		bpl $a386			bpl 	_SRCopy
.a38e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/loadcode.asm

.a38f					LoadBasicCode:
.a38f	a9 be		lda #$be			lda 	#(LBCTest) & $FF
.a391	85 10		sta $10				sta 	zTemp0
.a393	a9 a3		lda #$a3			lda 	#(LBCTest) >> 8
.a395	85 11		sta $11				sta 	zTemp0+1
.a397	a9 01		lda #$01			lda 	#($801) & $FF
.a399	85 12		sta $12				sta 	zTemp1
.a39b	a9 08		lda #$08			lda 	#($801) >> 8
.a39d	85 13		sta $13				sta 	zTemp1+1
.a39f					_LBCCopy:
.a39f	a0 02		ldy #$02			ldy 	#2							; skip over the loading address
.a3a1	b1 10		lda ($10),y			lda 	(zTemp0),y 					; skips first two bytes :)
.a3a3	92 12		sta ($12)			sta 	(zTemp1)
.a3a5	e6 10		inc $10				inc 	zTemp0
.a3a7	d0 02		bne $a3ab			bne 	_NoCarry
.a3a9	e6 11		inc $11				inc 	zTemp0+1
.a3ab					_NoCarry:
.a3ab	e6 12		inc $12				inc 	zTemp1
.a3ad	d0 02		bne $a3b1			bne 	_NoCarry
.a3af	e6 13		inc $13				inc 	zTemp1+1
.a3b1					_NoCarry:
.a3b1	a5 10		lda $10				lda 	zTemp0
.a3b3	c9 f9		cmp #$f9			cmp 	#LBCTestEnd & $FF
.a3b5	d0 e8		bne $a39f			bne 	_LBCCopy
.a3b7	a5 11		lda $11				lda 	zTemp0+1
.a3b9	c9 a3		cmp #$a3			cmp 	#LBCTestEnd >> 8
.a3bb	d0 e2		bne $a39f			bne 	_LBCCopy
.a3bd	60		rts				rts
.a3be					LBCTest:
>a3be	01 08 0c 08 e8 03 99 c7				.binary 	"../generated/test.prg"
>a3c6	28 31 34 29 00 17 08 f2 03 9e 34 30 39 36 30 00
>a3d6	38 08 fc 03 2f 2f 20 45 4e 44 49 46 20 2b 2b 20
>a3e6	2b 20 3e 3d 20 24 32 30 41 22 48 45 4c 4c 4f 22
>a3f6	00 00 00
.a3f9					LBCTestEnd:

;******  Return to file: main.asm

.a3f9					EndCode:

;******  End of listing
